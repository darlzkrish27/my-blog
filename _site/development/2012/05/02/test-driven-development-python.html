<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Test Driven Development in Python | Agiliq Blogs</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Test Driven Development in Python" />
<meta name="author" content="anoop" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="We can either prevent bad things from happening or fix it, once it is detected. It is your choice to select any of these methodology, while developing a software. You can either develop based on a test driven process or the recover from a fiasco with tests. Test driven development, as the name suggests, is development based on tests. Tests for core features are written prior to the implementation for the expected output, and then necessary modules are written to satisfy the needs define the Advantages of Test Driven Development application is determined by using it written minimal amount of application code total application + tests is probably more smaller simpler, stand-alone, minimal dependencies tends to result in extensible architectures instant feedback future development won’t break existing features. About Test Driven Development Write tests for the use case Run it (make sure it fails and fails miserably) Write code and implement the required functionality with relevant level of detail Run the test Write test for addition features Run all test Watch it succeed. Have a cup of coffee ! Basic Unittest import unittest class MyTest(unittest.TestCase): def testMethod(self): self.assertEqual(hello(5), 5, &quot;Hello din&#39;t return 5.&quot;) if __name__ == &#39;__main__&#39;: unittest.main() To write a basic unittest in python, is pretty straight forward. The code above is self explainatory. It is trying out hello function, and expected output is given as 5. If somehow, hello() din’t return 5, then the error message is printed to the console. Now, let’s try writing the function hello to satisfy the test. def hello(value): return 5 or def hello(value): return value This is a problem! The problem is, how to select the best. Solution is, to get the tests more detailed and covering more test cases to satisfy the requiements of the function. As we have more precise requirements in the tests, we can easily rule out either the more complex solutions or the more simpler solutions, and get the perfect balance between development and requirement. One thing to keep in mind while doing Test Driven Development is, Don’t Overkill. Just write tests for the core features expected, and write it expecting all the complete range. For example, if it is a multiplication function, make sure that you need make sure that you handle strings as you need it. Another Example An example for doing test driven development for greater than function is given below. The requirement is crazy, to compare the ascii sum of the text string if argument is a string. The Test import unittest from demo import Greater class DemoTest(unittest.TestCase): def test_number(self): comparator = Greater() result = comparator.greater(10,5) self.assertTrue(result) def test_char(self): comparator = Greater() result = comparator.greater(&#39;ABCabcxyz&#39;, &#39;ABa&#39;) self.assertTrue(result) def test_char_equal(self): comparator = Greater() result = comparator.greater(&#39;4&#39;, 3) self.assertTrue(result) if __name__ == &#39;__main__&#39;: unittest.main() Now the Code class Greater(object): def greater(self, val1, val2): if type(val1) ==str or type(val2) == str: val1 = str(val1) val2 = str(val2) sum1 = sum([ord(i) for i in val1]) sum2 = sum([ord(i) for i in val2]) if sum1 &gt; sum2: return True else: return False if val1&gt;val2: return True else: return False The function returns True or False, based on the ascii values if any of the argument is string, else give the greater. Note: A presentation on the topic is available http://www.slideshare.net/atmb4u/test-driven-development-in-python TL; DR: Write tests to satisfy requirements, then write code. Have a peaceful life ! Have a happy Test Driven Development!!!" />
<meta property="og:description" content="We can either prevent bad things from happening or fix it, once it is detected. It is your choice to select any of these methodology, while developing a software. You can either develop based on a test driven process or the recover from a fiasco with tests. Test driven development, as the name suggests, is development based on tests. Tests for core features are written prior to the implementation for the expected output, and then necessary modules are written to satisfy the needs define the Advantages of Test Driven Development application is determined by using it written minimal amount of application code total application + tests is probably more smaller simpler, stand-alone, minimal dependencies tends to result in extensible architectures instant feedback future development won’t break existing features. About Test Driven Development Write tests for the use case Run it (make sure it fails and fails miserably) Write code and implement the required functionality with relevant level of detail Run the test Write test for addition features Run all test Watch it succeed. Have a cup of coffee ! Basic Unittest import unittest class MyTest(unittest.TestCase): def testMethod(self): self.assertEqual(hello(5), 5, &quot;Hello din&#39;t return 5.&quot;) if __name__ == &#39;__main__&#39;: unittest.main() To write a basic unittest in python, is pretty straight forward. The code above is self explainatory. It is trying out hello function, and expected output is given as 5. If somehow, hello() din’t return 5, then the error message is printed to the console. Now, let’s try writing the function hello to satisfy the test. def hello(value): return 5 or def hello(value): return value This is a problem! The problem is, how to select the best. Solution is, to get the tests more detailed and covering more test cases to satisfy the requiements of the function. As we have more precise requirements in the tests, we can easily rule out either the more complex solutions or the more simpler solutions, and get the perfect balance between development and requirement. One thing to keep in mind while doing Test Driven Development is, Don’t Overkill. Just write tests for the core features expected, and write it expecting all the complete range. For example, if it is a multiplication function, make sure that you need make sure that you handle strings as you need it. Another Example An example for doing test driven development for greater than function is given below. The requirement is crazy, to compare the ascii sum of the text string if argument is a string. The Test import unittest from demo import Greater class DemoTest(unittest.TestCase): def test_number(self): comparator = Greater() result = comparator.greater(10,5) self.assertTrue(result) def test_char(self): comparator = Greater() result = comparator.greater(&#39;ABCabcxyz&#39;, &#39;ABa&#39;) self.assertTrue(result) def test_char_equal(self): comparator = Greater() result = comparator.greater(&#39;4&#39;, 3) self.assertTrue(result) if __name__ == &#39;__main__&#39;: unittest.main() Now the Code class Greater(object): def greater(self, val1, val2): if type(val1) ==str or type(val2) == str: val1 = str(val1) val2 = str(val2) sum1 = sum([ord(i) for i in val1]) sum2 = sum([ord(i) for i in val2]) if sum1 &gt; sum2: return True else: return False if val1&gt;val2: return True else: return False The function returns True or False, based on the ascii values if any of the argument is string, else give the greater. Note: A presentation on the topic is available http://www.slideshare.net/atmb4u/test-driven-development-in-python TL; DR: Write tests to satisfy requirements, then write code. Have a peaceful life ! Have a happy Test Driven Development!!!" />
<link rel="canonical" href="http://localhost:4000/development/2012/05/02/test-driven-development-python.html" />
<meta property="og:url" content="http://localhost:4000/development/2012/05/02/test-driven-development-python.html" />
<meta property="og:site_name" content="Agiliq Blogs" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2012-05-02T20:41:12+05:30" />
<script type="application/ld+json">
{"description":"We can either prevent bad things from happening or fix it, once it is detected. It is your choice to select any of these methodology, while developing a software. You can either develop based on a test driven process or the recover from a fiasco with tests. Test driven development, as the name suggests, is development based on tests. Tests for core features are written prior to the implementation for the expected output, and then necessary modules are written to satisfy the needs define the Advantages of Test Driven Development application is determined by using it written minimal amount of application code total application + tests is probably more smaller simpler, stand-alone, minimal dependencies tends to result in extensible architectures instant feedback future development won’t break existing features. About Test Driven Development Write tests for the use case Run it (make sure it fails and fails miserably) Write code and implement the required functionality with relevant level of detail Run the test Write test for addition features Run all test Watch it succeed. Have a cup of coffee ! Basic Unittest import unittest class MyTest(unittest.TestCase): def testMethod(self): self.assertEqual(hello(5), 5, &quot;Hello din&#39;t return 5.&quot;) if __name__ == &#39;__main__&#39;: unittest.main() To write a basic unittest in python, is pretty straight forward. The code above is self explainatory. It is trying out hello function, and expected output is given as 5. If somehow, hello() din’t return 5, then the error message is printed to the console. Now, let’s try writing the function hello to satisfy the test. def hello(value): return 5 or def hello(value): return value This is a problem! The problem is, how to select the best. Solution is, to get the tests more detailed and covering more test cases to satisfy the requiements of the function. As we have more precise requirements in the tests, we can easily rule out either the more complex solutions or the more simpler solutions, and get the perfect balance between development and requirement. One thing to keep in mind while doing Test Driven Development is, Don’t Overkill. Just write tests for the core features expected, and write it expecting all the complete range. For example, if it is a multiplication function, make sure that you need make sure that you handle strings as you need it. Another Example An example for doing test driven development for greater than function is given below. The requirement is crazy, to compare the ascii sum of the text string if argument is a string. The Test import unittest from demo import Greater class DemoTest(unittest.TestCase): def test_number(self): comparator = Greater() result = comparator.greater(10,5) self.assertTrue(result) def test_char(self): comparator = Greater() result = comparator.greater(&#39;ABCabcxyz&#39;, &#39;ABa&#39;) self.assertTrue(result) def test_char_equal(self): comparator = Greater() result = comparator.greater(&#39;4&#39;, 3) self.assertTrue(result) if __name__ == &#39;__main__&#39;: unittest.main() Now the Code class Greater(object): def greater(self, val1, val2): if type(val1) ==str or type(val2) == str: val1 = str(val1) val2 = str(val2) sum1 = sum([ord(i) for i in val1]) sum2 = sum([ord(i) for i in val2]) if sum1 &gt; sum2: return True else: return False if val1&gt;val2: return True else: return False The function returns True or False, based on the ascii values if any of the argument is string, else give the greater. Note: A presentation on the topic is available http://www.slideshare.net/atmb4u/test-driven-development-in-python TL; DR: Write tests to satisfy requirements, then write code. Have a peaceful life ! Have a happy Test Driven Development!!!","author":{"@type":"Person","name":"anoop"},"@type":"BlogPosting","url":"http://localhost:4000/development/2012/05/02/test-driven-development-python.html","headline":"Test Driven Development in Python","dateModified":"2012-05-02T20:41:12+05:30","datePublished":"2012-05-02T20:41:12+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/development/2012/05/02/test-driven-development-python.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Agiliq Blogs" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Agiliq Blogs</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Test Driven Development in Python </h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2012-05-02T20:41:12+05:30" itemprop="datePublished">May 2, 2012
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">anoop</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <blockquote>
  <p>We can either prevent bad things from
happening or fix it, once it is
detected.</p>
</blockquote>

<p>It is your choice to select any of these methodology, while developing a software. You can either develop based on a test driven process or the recover from a fiasco with tests.</p>

<p>Test driven development, as the name suggests, is development based on tests. Tests for core features are written prior to the implementation for the expected output, and then necessary modules are written to satisfy the needs define the</p>

<hr />

<p><strong>Advantages of Test Driven Development</strong></p>

<ul>
  <li>application is determined by using it</li>
  <li>written minimal amount of application code</li>
  <li>total application + tests is probably more smaller</li>
  <li>simpler, stand-alone, minimal dependencies</li>
  <li>tends to result in extensible architectures</li>
  <li>instant feedback</li>
  <li>future development won’t break existing features.</li>
</ul>

<hr />

<p><strong>About Test Driven Development</strong></p>

<ul>
  <li>Write tests for the use case Run it</li>
  <li>(make sure it fails and fails</li>
  <li>miserably) Write code and implement</li>
  <li>the required functionality with relevant level of detail</li>
  <li>Run the test</li>
  <li>Write test for addition features</li>
  <li>Run all test Watch it succeed. Have a cup of coffee !</li>
</ul>

<p><strong>Basic Unittest</strong></p>

<hr />

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import unittest
class MyTest(unittest.TestCase):
    def testMethod(self):
        self.assertEqual(hello(5), 5, "Hello din't return 5.")

if __name__ == '__main__':
    unittest.main()
</code></pre></div></div>

<p>To write a basic unittest in python, is pretty straight forward. The code above is self explainatory. It is trying out hello function, and expected output is given as 5. If somehow, hello() din’t return 5, then the error message is printed to the console.</p>

<p>Now, let’s try writing the function hello to satisfy the test.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def hello(value):
    return 5
</code></pre></div></div>

<p>or</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def hello(value):
    return value
</code></pre></div></div>

<p><strong>This is a problem!</strong></p>

<p>The problem is, how to select the best. Solution is, to get the tests more detailed and covering more test cases to satisfy the requiements of the function. As we have more precise requirements in the tests, we can easily rule out either the more complex solutions or the more simpler solutions, and get the perfect balance between development and requirement.</p>

<p>One thing to keep in mind while doing Test Driven Development is, <strong><em>Don’t Overkill</em></strong>. Just write tests for the core features expected, and write it expecting all the complete range. For example, if it is a multiplication function, make sure that you need make sure that you handle strings as you need it.</p>

<p>Another Example</p>

<p>An example for doing test driven development for greater than function is given below.</p>

<p>The requirement is crazy, to compare the <em>ascii sum of the text string</em> if argument is a string.</p>

<p><strong>The Test</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import unittest
from demo import Greater
class DemoTest(unittest.TestCase):
    def test_number(self):
        comparator = Greater()
        result = comparator.greater(10,5)
        self.assertTrue(result)
    def test_char(self):
        comparator = Greater()
        result = comparator.greater('ABCabcxyz', 'ABa')
        self.assertTrue(result)
    def test_char_equal(self):
        comparator = Greater()
        result = comparator.greater('4', 3)
        self.assertTrue(result)
if __name__ == '__main__':
    unittest.main()
</code></pre></div></div>

<p><strong>Now the Code</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Greater(object):
    def greater(self, val1, val2):
        if type(val1) ==str or type(val2) == str:
           val1 = str(val1)
           val2 = str(val2)
           sum1 = sum([ord(i) for i in val1])
           sum2 = sum([ord(i) for i in val2])
           if sum1 &gt; sum2:
               return True
           else:
               return False
        if val1&gt;val2:
            return True
        else:
            return False
</code></pre></div></div>

<p>The function returns True or False, based on the ascii values if any of the argument is  string, else give the greater.</p>

<p>Note: A presentation on the topic is available <a href="http://www.slideshare.net/atmb4u/test-driven-development-in-python">http://www.slideshare.net/atmb4u/test-driven-development-in-python</a></p>

<blockquote>
  <p><strong>TL; DR:  Write tests to satisfy requirements, then write code. Have a peaceful life !</strong></p>
</blockquote>

<p>Have a happy Test Driven Development!!!</p>


  </div><a class="u-url" href="/development/2012/05/02/test-driven-development-python.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Agiliq Blogs</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Agiliq Blogs</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
